(* MAIN PARTS OF THE PROGRAM *)

program = function_definition, {function_definition | class_definition};

function_definition = "define", identifier, "(" parameters ")" block;
class_definition = "class", identifier, block;

(* TODO: this *)

block = "{" {statement} "}";
class_block = {function_definition} ;

parameters = [identifier, {",", identifier}];

statement = conditional | loop | function_call | assign | return | comment | method_call;


(* EXPRESSIONS *)

(* DEFAULT KEYWORDS *)
conditional = "if" or_expression block,
                {"else if" or_expression block},
                {"else" block}
loop = while_loop | foreach_loop;
function_call = identifier, rest_function_call;
rest_function_call = "(" arguments ")";

assign = assign_var | assign_list | assign_this;
return = "return", or_expression, ";" ;
this_kw = "this";
reflect = "reflect", ["recursive"] or_expression;

list_value = "[" [or_expression, {",", or_expression}] "]";



while_loop = "while", or_expression, block;
foreach_loop = "foreach", identifier, "in", or_expression, block;
assign_var = identifier, "=", or_expression, ";" ;
assign_list = identifier, "[", number, "]", "=", or_expression, ";" ;
assign_this = this_kw, access_oper, value_getter, "=", or_expression;

arguments = [["by_ref"], or_expression, {",", ["by_ref"] or_expression}]

comment = "#", comment_text;
comment_text = {special_char | string | number | other_char} newline;


(* OPERATORS *)

(* LOGICAL *)
and_oper = "&&";
or_oper = "||";
not_oper = "!";


(* ARITHMETICAL *)
add_oper = "+" | "-";
mult_oper_general = mult_oper | modulo_oper;
mult_oper = "*" | "/";
modulo_oper = "%";
negative = "-";

(* RELATION *)
relation_oper = "<" | ">" | "<=" | ">=";
equality_oper = "==" | "!=";

(* DATA ACCESS *)
access_oper = ".";



(* OPERATOR PRIORITIES *)
or_expression = and_expression or_oper and_expression;
and_expression = equality_expression { and_oper equality_expression };
equality_expression = relation_expression relation_oper relation_expression;
relation_expression = add_expression relation_oper add_expression;

add_expression = multiply_expression { add_oper multiply_expression };
multiply_expression = unary_expression { mult_oper_general unary_expression }
unary_expression = general_value | not_unary_expression | negative_unary_expression;

not_unary_expression = not_oper, unary_expression;
negative_unary_expression = negative, unary_expression;

general_value = value | "(", or_expression, ")"; # a = [1,2,3] + !return_collection([1,2,3])
value = literal | value_getter | list_value | collection_elem;

identifier = ((underscore | dollar_sign | letter) (letter | digit | underscore)) | letter) {letter | underscore | digit};

(* valid identifier *)
identifier = ((underscore | dollar_sign) | letter), {letter | underscore | digit};

basic_value_getter = (identifer, [rest_function_call]);
value_getter = basic_value_getter {access_oper basic_value_getter} ;

(* VARIABLES AND LITERALS *)
collection_elem = identifier, {"[", add_expression, "]"};

literal = string | number | bool;
bool = "true" | "false";

string = "\"" {character} "\"";
character = letter | digit | special_char;

(* TODO: What about double numbers???*)
number = non_zero_number | "0";
non_zero_number = non_zero_digit {digit};

digit = non_zero_digit | '0';
non_zero_digit = '1' - '9';

letter = 'A' - 'Z' | 'a' - 'z';
special_char = ";" | "\"" | "'" |"-" | "." | "," | "/" | "\\" | underscore | dollar_sign | whitespace | "#" ;
other_sp_char = "=" | "?" | "!" | "[" | "]" | "(" | ")" | "{" | "}" | "<" | ">";


newline = '\n';
underscore = '_';